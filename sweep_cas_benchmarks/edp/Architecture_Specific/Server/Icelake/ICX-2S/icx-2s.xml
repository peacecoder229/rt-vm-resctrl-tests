<?xml version="1.0"?>
<root>
	<metric name="metric_CPU operating frequency (in GHz)">
        <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
		<event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
		<constant alias="c">system.tsc_freq</constant>      
		<formula>(a/b*c)/1000000000</formula>
	</metric>

	<metric name="metric_CPU utilization %">
		<event alias="a">CPU_CLK_UNHALTED.REF_TSC</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CPU utilization% in kernel mode">
		<event alias="a">CPU_CLK_UNHALTED.REF_TSC:SUP</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CPI">
		<throughput-metric-name>metric_cycles per txn</throughput-metric-name>
		<event alias="a">CPU_CLK_UNHALTED.THREAD</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

    <metric name="metric_kernel_CPI">
        <event alias="a">CPU_CLK_UNHALTED.THREAD:SUP</event>
        <event alias="b">INST_RETIRED.ANY:SUP</event>
        <formula>a/b</formula>
    </metric>

   <metric name="metric_EMON event mux reliability% (>95% good)">
        <event alias="a">CPU_CLK_UNHALTED.THREAD_P</event>
        <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
        <formula>100*(((a-b)&lt;0)?(a/b):(b/a))</formula>
    </metric>

 	<metric name="metric_branch mispredict ratio">
		<event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
		<event alias="b">BR_INST_RETIRED.ALL_BRANCHES</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_loads per instr">
        <throughput-metric-name>metric_loads per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.ALL_LOADS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_stores per instr">
        <throughput-metric-name>metric_stores per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.ALL_STORES</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_locks retired per instr">
        <throughput-metric-name>metric_locks retired per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.LOCK_LOADS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_streaming stores per instr">
        <throughput-metric-name>metric_streaming stores (full line) per txn</throughput-metric-name>
		<event alias="a">OCR.STREAMING_WR.ANY_RESPONSE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_L1D MPI (includes data+rfo w/ prefetches)">
        <throughput-metric-name>metric_L1D misses per txn (includes data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">L1D.REPLACEMENT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L1D demand data read hits per instr">
        <throughput-metric-name>metric_L1D demand data read hits per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L1_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L1-I code read misses (w/ prefetches) per instr">
        <throughput-metric-name>metric_L1I code read misses (includes prefetches) per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.ALL_CODE_RD</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 demand data read hits per instr">
        <throughput-metric-name>metric_L2 demand data read hits per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L2_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 MPI (includes code+data+rfo w/ prefetches)">
        <throughput-metric-name>metric_L2 misses per txn (includes code+data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">L2_LINES_IN.ALL</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
 	<metric name="metric_L2 demand data read MPI">
        <throughput-metric-name>metric_L2 demand data read misses per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L2_MISS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
	<metric name="metric_L2 demand code MPI">
        <throughput-metric-name>metric_L2 demand code misses per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.CODE_RD_MISS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 Any local request that HITM in a sibling core (per instr)">
        <throughput-metric-name>metric_L2 Any local request that HITM in a sibling core per txn</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.L3_HIT.SNOOP_HITM</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>	

	<metric name="metric_L2 Any local request that HIT in a sibling core and forwarded(per instr)">
        <throughput-metric-name>metric_L2 Any local request that HIT in a sibling core and forwarded per txn</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.L3_HIT.SNOOP_HIT_WITH_FWD</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>

	<metric name="metric_L2 all L2 prefetches(per instr)">
        <throughput-metric-name>metric_L2 all L2 prefetches per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.ALL_HWPF</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>	
	
	<metric name="metric_L2 % of all lines evicted that are unused prefetches">
		<event alias="a">L2_LINES_OUT.USELESS_HWPF</event>
		<event alias="b">L2_LINES_OUT.NON_SILENT</event>
		<event alias="c">L2_LINES_OUT.SILENT</event>
		<constant alias="threads">system.sockets[0][0].size</constant>      
		<formula>100*a/(b+(c/threads))</formula>
	</metric>

	<metric name="metric_L2 % of L2 evictions that are allocated into L3">
		<event alias="a">L2_LINES_OUT.NON_SILENT</event>
		<event alias="b">IDI_MISC.WB_DOWNGRADE</event>
		<formula>100*(a-b)/a</formula>
	</metric>

	<metric name="metric_L2 % of L2 evictions that are NOT allocated into L3">
		<event alias="a">L2_LINES_OUT.NON_SILENT</event>
		<event alias="b">IDI_MISC.WB_DOWNGRADE</event>
		<formula>100*b/a</formula>
	</metric>

	<metric name="metric_Load_L2_Miss_Latency_using_ORO_events(ns)">
		<event alias="a">OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD</event>
		<event alias="b">OFFCORE_REQUESTS.DEMAND_DATA_RD</event>		
        <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
        <event alias="d">CPU_CLK_UNHALTED.REF_TSC</event>
        <constant alias="e">system.tsc_freq</constant>
        <formula>1000000000*(a/b)/(c/d*e)</formula>
	</metric>	

	<metric name="metric_LLC code references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC code references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_CRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC data read references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC data read references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFDRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_DRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_DRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC RFO references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC RFO references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFRFO</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_RFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_RFO_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC MPI (includes code+data+rfo w/ prefetches)">
        <throughput-metric-name>metric_LLC misses per txn (includes code+data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_CRD_PREF</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="e">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
		<event alias="f">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF</event>
		<event alias="g">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="h">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="j">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<event alias="k">INST_RETIRED.ANY</event>
		<formula>(a+b+c+d+e+f+g+h+j)/k</formula>
	</metric>

	<metric name="metric_LLC data read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC data read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC RFO read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC RFO read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC code read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC code read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_CRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC all LLC prefetches (per instr)">
        <throughput-metric-name>metric_LLC LLC prefetches per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC total HITM (per instr) (excludes LLC prefetches)">
        <throughput-metric-name>metric_LLC total HITM per txn (excludes LLC prefetches)</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.REMOTE_CACHE.SNOOP_HITM</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_LLC total HIT clean line forwards (per instr) (excludes LLC prefetches)">
        <throughput-metric-name>metric_LLC total HIT clean line forwards per txn (excludes LLC prefetches)</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.REMOTE_CACHE.SNOOP_HIT_WITH_FWD</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
    
	<metric name="metric_Load_L3_Miss_Latency_using_ORO_events(ns)">
		<event alias="a">OFFCORE_REQUESTS_OUTSTANDING.L3_MISS_DEMAND_DATA_RD</event>
		<event alias="b">OFFCORE_REQUESTS.L3_MISS_DEMAND_DATA_RD</event>		
        <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
        <event alias="d">CPU_CLK_UNHALTED.REF_TSC</event>
        <constant alias="e">system.tsc_freq</constant>
        <formula>1000000000*(a/b)/(c/d*e)</formula>
	</metric>	

    <metric name="metric_Average LLC demand data read miss latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_Average LLC demand RFO miss latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_RFO</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula> 
    </metric>

    <metric name="metric_Average LLC demand data read miss latency for LOCAL requests (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_LOCAL</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

	<metric name="metric_Average LLC demand data read miss latency for REMOTE requests (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_REMOTE</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

     <metric name="metric_Average LLC demand data read miss to DCPMEM latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_PMM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PMM</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_Average LLC demand data read miss to DRAM latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_DRAM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_DRAM</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

	<metric name="metric_LLC % SpecI2M  vs total Ownership req)">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_SPECITOM</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<formula>(a)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_SF snoop filter capacity evictions (per instr)">
        <throughput-metric-name>metric_SF snoop filter capacity evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_SF_EVICTION.M_STATE</event>
		<event alias="b">UNC_CHA_SF_EVICTION.S_STATE</event>
		<event alias="c">UNC_CHA_SF_EVICTION.E_STATE</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_SF % of L3 accesses that result in SF capacity evictions">
		<event alias="a">UNC_CHA_SF_EVICTION.M_STATE</event>
		<event alias="b">UNC_CHA_SF_EVICTION.S_STATE</event>
		<event alias="c">UNC_CHA_SF_EVICTION.E_STATE</event>
		<event alias="d">L2_LINES_IN.ALL</event>
		<formula>100*(a+b+c)/d</formula>
	</metric>

	<metric name="metric_ITLB (2nd level) MPI">
        <throughput-metric-name>metric_ITLB (2nd level) misses per txn</throughput-metric-name>
		<event alias="a">ITLB_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_ITLB (2nd level) large page MPI">
        <throughput-metric-name>metric_ITLB (2nd level) large page misses per txn</throughput-metric-name>
		<event alias="a">ITLB_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_STLB data page hits per instr">
        <throughput-metric-name>metric_STLB data page hits per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) 4KB page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 4KB page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<event alias="b">DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="c">DTLB_LOAD_MISSES.WALK_COMPLETED_1G</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a-b-c)/d</formula>
	</metric>
	
	<metric name="metric_DTLB (2nd level) 2MB large page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 2MB large page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) 1GB large page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 1GB large page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED_1G</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
	<metric name="metric_DTLB (2nd level) store MPI">
        <throughput-metric-name>metric_DTLB (2nd level) store misses per txn</throughput-metric-name>
		<event alias="a">DTLB_STORE_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB load miss latency (in core clks)">
		<event alias="a">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
		<event alias="b">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB store miss latency (in core clks)">
		<event alias="a">DTLB_STORE_MISSES.WALK_ACTIVE</event>
		<event alias="b">DTLB_STORE_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_ITLB miss latency (in core clks)">
		<event alias="a">ITLB_MISSES.WALK_ACTIVE</event>
		<event alias="b">ITLB_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_NUMA %_Reads addressed to local DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE</event>
		<formula>100*(a+b)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_NUMA %_Reads addressed to remote DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE</event>
		<formula>100*(c+d)/(a+b+c+d)</formula>
	</metric>
	
	<metric name="metric_NUMA %_RFOs addressed to local DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_REMOTE</event>
		<formula>100*(a+b)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_NUMA %_RFOs addressed to remote DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_REMOTE</event>
		<formula>100*(c+d)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_uncore frequency GHz">
        <event alias="a">UNC_CHA_CLOCKTICKS</event>
        <constant alias="b">system.cha_count/system.socket_count</constant>
        <constant alias="socket_count">system.socket_count</constant>
        <formula>a/(b*socket_count)/1000000000</formula>
        <formula socket="0">a[0]/b/1000000000</formula>
        <formula socket="1">a[1]/b/1000000000</formula>
    </metric>

     <metric name="metric_UPI speed - GT/s">
        <constant alias="socket_count">system.socket_count</constant>
        <constant alias="links_per_socket">3</constant>
        <event alias="a">UNC_UPI_CLOCKTICKS</event>
        <event alias="tsc">TSC</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <event alias="c6">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
       <constant alias="d">system.sockets[0].cores.count</constant>
  		<constant alias="threads">system.sockets[0][0].size</constant>      
        <formula>(((tsc/(d*threads)) / ((tsc/(d*threads)) - c6))*(a-f))  /(socket_count*links_per_socket)*8/1000000000</formula>
        <formula socket="0">((tsc/(d*threads)) / ((tsc/(d*threads)) - c6[0])*(a[0]-f[0]))/links_per_socket*8/1000000000</formula>
        <formula socket="1">((tsc/(d*threads)) / ((tsc/(d*threads)) - c6[1])*(a[1]-f[1]))/links_per_socket*8/1000000000</formula>
    </metric>

    <metric name="metric_UPI Data transmit BW (MB/sec) (only data)">
        <event alias="a">UNC_UPI_TxL_FLITS.ALL_DATA</event>
       <!-- 9 flits are needed to transmit a full cache line -->
        <formula>a*(64/9.0)/1000000</formula>
    </metric>

    <metric name="metric_UPI Transmit utilization_% (includes control)">
       <constant alias="socket_count">system.socket_count</constant>
        <constant alias="links_per_socket">3</constant>
        <event alias="a">UNC_UPI_CLOCKTICKS</event>
        <event alias="tsc">TSC</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <event alias="c6">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
        <event alias="g">UNC_UPI_TxL_FLITS.ALL_DATA</event>
        <event alias="h">UNC_UPI_TxL_FLITS.NON_DATA</event>
       <constant alias="d">system.sockets[0].cores.count</constant>
  		<constant alias="threads">system.sockets[0][0].size</constant>      
        <!-- 5 flits are sent in every 6 clocks; NULL flits are sent across all 3 slots and hence b/3 -->
		<!-- So useful flits (non-idle) == (clocks*5/6) - (null_flits/3) -->	
        <formula>100*((g+h)/3)/(((((tsc/(d*threads)) / ((tsc/(d*threads)) - c6))*(a-f))*5/6))</formula>
    </metric>

    <metric name="metric_UPI % cycles transmit link is half-width (L0p)">
        <event alias="a">UNC_UPI_TxL0P_POWER_CYCLES</event>
        <event alias="b">UNC_UPI_CLOCKTICKS</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <formula>100*(a/(b-f))</formula>
    </metric>

    <metric name="metric_UPI % cycles receive link is half-width (L0p)">
        <event alias="a">UNC_UPI_RxL0P_POWER_CYCLES</event>
        <event alias="b">UNC_UPI_CLOCKTICKS</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <formula>100*(a/(b-f))</formula>
    </metric>

    <metric name="metric_HA - Reads vs. all requests">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="c">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <event alias="d">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>(a+c)/(a+b+c+d)</formula>
    </metric>

    <metric name="metric_HA - Writes vs. all requests">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="c">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <event alias="d">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>(b+d)/(a+b+c+d)</formula>
    </metric>

    <metric name="metric_HA % of all reads that are local">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <formula>100*a/(a+b)</formula>
    </metric>

    <metric name="metric_HA % of all writes that are local">
      <event alias="a">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>100*a/(a+b)</formula>
    </metric>

    <metric name="metric_HA conflict responses per instr">
        <throughput-metric-name>metric_HA conflict responses per txn</throughput-metric-name>
      <event alias="a">UNC_CHA_SNOOP_RESP.RSPCNFLCTS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_HA directory lookups that spawned a snoop (per instr)">
        <throughput-metric-name>metric_HA directory lookups that spawned a snoop (per txn)</throughput-metric-name>
      <event alias="a">UNC_CHA_DIR_LOOKUP.SNP</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_HA directory lookups that did not spawn a snoop (per instr)">
        <throughput-metric-name>metric_HA directory lookups that did not spawn a snoop (per txn)</throughput-metric-name>
      <event alias="a">UNC_CHA_DIR_LOOKUP.NO_SNP</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_M2M directory updates (per instr)">
        <throughput-metric-name>metric_M2M directory updates (per txn)</throughput-metric-name>
		<event alias="a">UNC_CHA_DIR_UPDATE.HA</event>
		<event alias="b">UNC_CHA_DIR_UPDATE.TOR</event>
		<event alias="c">UNC_M2M_DIRECTORY_UPDATE.ANY</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
    </metric>

    <metric name="metric_M2M XPT prefetches (per instr)">
        <throughput-metric-name>metric_M2M XPT prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
    </metric>
	
    <metric name="metric_M3UPI UPI prefetches (per instr)">
        <throughput-metric-name>metric_M3UPI UPI prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
    </metric>
	
    <metric name="metric_M2M extra reads from XPT-UPI prefetches (per instr)">
        <throughput-metric-name>metric_M2M useless XPT-UPI prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
		<event alias="b">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
		<event alias="c">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
		<event alias="d">UNC_M2M_PREFCAM_DEMAND_MERGE.UPI_ALLCH</event>
		<event alias="e">INST_RETIRED.ANY</event>
		<formula>((a+b)-(c+d))/e</formula>
    </metric>
	
    <metric name="metric_DDR data rate (MT/sec)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <constant alias="socket_count">system.socket_count</constant>
        <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <formula>2*a/(socket_count*channels_populated_per_socket)/1000000</formula>
        <formula socket="0">2*a[0]/channels_populated_per_socket/1000000</formula>
	 	<formula socket="1">2*a[1]/channels_populated_per_socket/1000000</formula>
     </metric>

    <metric name="metric_memory bandwidth read (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_memory bandwidth write (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.WR</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_memory bandwidth total (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <event alias="b">UNC_M_CAS_COUNT.WR</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_memory extra write b/w due to directory updates (MB/sec)">
		<event alias="a">UNC_CHA_DIR_UPDATE.HA</event>
		<event alias="b">UNC_CHA_DIR_UPDATE.TOR</event>
		<event alias="c">UNC_M2M_DIRECTORY_UPDATE.ANY</event>
        <formula>(a+b+c)*64/1000000</formula>
    </metric>

    <metric name="metric_memory extra read b/w due to XPT/UPI prefetches (MB/sec)">
        <event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <event alias="b">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
        <event alias="d">UNC_M2M_PREFCAM_DEMAND_MERGE.UPI_ALLCH</event>
        <formula>(a-b+c-d)*64/1000000</formula>
    </metric>
	
    <metric name="metric_DCPMEM_memory_mode near memory cache read miss rate%">
		<event alias="a">UNC_M_TAGCHK.HIT</event>
		<event alias="b">UNC_M_TAGCHK.MISS_CLEAN</event>
		<event alias="c">UNC_M_TAGCHK.MISS_DIRTY</event>
        <formula>100*(b+c)/(a+b+c)</formula>
    </metric>
	
    <metric name="metric_memory RPQ PCH0 read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_INSERTS.PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>
	
    <metric name="metric_memory RPQ PCH1 read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_INSERTS.PCH1</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>

    <metric name="metric_memory avg entries in RPQ">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
       <formula>(b+c)/(a/2)</formula>
    </metric>

    <metric name="metric_memory avg entries in RPQ when not empty">
        <event alias="a">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <event alias="b">UNC_M_RPQ_CYCLES_NE.PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
        <event alias="d">UNC_M_RPQ_CYCLES_NE.PCH1</event>
       <formula>(a/b)+(c/d)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_CYCLES_NE.PCH0</event>
       <formula>100*(1-c/(a/2))</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_CYCLES_NE.PCH0</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when RPQ PCH0 has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=10</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=20</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=30</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	
    <metric name="metric_memory WPQ PCH0 write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_INSERTS.PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>
	
    <metric name="metric_memory WPQ PCH1 write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_INSERTS.PCH1</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>

    <metric name="metric_memory avg entries in WPQ">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
       <formula>(b+c)/(a/2)</formula>
    </metric>

<!--
    <metric name="metric_memory avg entries in WPQ when not empty">
        <event alias="a">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <event alias="b">UNC_M_WPQ_CYCLES_NE.PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
        <event alias="d">UNC_M_WPQ_CYCLES_NE.PCH1</event>
       <formula>(a/b)+(c/d)</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_CYCLES_NE.PCH0</event>
       <formula>100*(1-c/(a/2))</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_CYCLES_NE.PCH0</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=10</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=20</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=30</event>
       <formula>100*c/(a/2)</formula>
    </metric>
-->	
    <metric name="metric_3DXP_memory bandwidth read (MB/sec)">
        <event alias="a">UNC_M_PMM_RPQ_INSERTS</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP_memory bandwidth write (MB/sec)">
        <event alias="a">UNC_M_PMM_WPQ_INSERTS</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP_memory bandwidth total (MB/sec)">
        <event alias="a">UNC_M_PMM_RPQ_INSERTS</event>
        <event alias="b">UNC_M_PMM_WPQ_INSERTS</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP memory RPQ read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_INSERTS</event>
        <event alias="c">UNC_M_PMM_RPQ_OCCUPANCY.ALL</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0])/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1])/(channels_populated_per_socket)))*1000000000</formula> 
    </metric>

    <metric name="metric_3DXP avg entries in RPQ">
        <event alias="b">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_PMM_RPQ_OCCUPANCY.ALL</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>c/((b)*dcpmm_dimms_per_socket/channels_populated_per_socket)</formula>
    </metric>
	
    <metric name="metric_3DXP avg entries in RPQ when not empty">
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_PMM_RPQ_OCCUPANCY.ALL</event>
       <formula>c/b</formula>
    </metric>

    <metric name="metric_3DXP % cycles when RPQ is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1</event>
      <formula>100*(1-(b/(a)))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=10</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 24 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=24</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 36 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=36</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) RPQ not empty">
        <event alias="a">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) RPQ empty">
        <event alias="a">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constants below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>(((c)*dcpmm_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with 36 or more entries in RPQ">
        <event alias="a">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=36:e1</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=36</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with less than 36 entries in RPQ">
        <event alias="a">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=36:e1</event>
        <event alias="b">UNC_M_PMM_RPQ_OCCUPANCY.ALL:t=36</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>(((c)*dcpmm_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>
	
	<metric name="metric_3DXP memory WPQ write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_INSERTS</event>
        <event alias="c">UNC_M_PMM_WPQ_OCCUPANCY.ALL</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0])/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1])/(channels_populated_per_socket)))*1000000000</formula> 
    </metric>
	
    <metric name="metric_3DXP avg entries in WPQ">
        <event alias="b">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_PMM_WPQ_OCCUPANCY.ALL</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>c/((b)*dcpmm_dimms_per_socket/channels_populated_per_socket)</formula>
    </metric>
	
    <metric name="metric_3DXP avg entries in WPQ when not empty">
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_PMM_WPQ_OCCUPANCY.ALL</event>
       <formula>c/b</formula>
    </metric>
	
   <metric name="metric_3DXP % cycles when WPQ has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=10</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
      <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>
	
    <metric name="metric_3DXP % cycles when WPQ is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>100*(1-(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket)))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=20</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
      <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=30</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
      <formula>100*(b/((a)*dcpmm_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) WPQ not empty">
        <event alias="a">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1</event>
       <formula>b/a</formula>
    </metric>
	
   <metric name="metric_3DXP avg time (dclk) WPQ empty">
        <event alias="a">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>(((c)*dcpmm_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with 30 or more entries in WPQ">
        <event alias="a">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=30:e1</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=30</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with less than 30 entries in WPQ">
        <event alias="a">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=30:e1</event>
        <event alias="b">UNC_M_PMM_WPQ_OCCUPANCY.ALL:t=30</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="dcpmm_dimms_per_socket">8</constant>
       <formula>(((c)*dcpmm_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

	<metric name="metric_CHA % OSB Loc InvItoE">
		<event alias="a">UNC_CHA_OSB.LOCAL_INVITOE</event>
        <event alias="b">UNC_CHA_REQUESTS.INVITOE_LOCAL</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CHA % OSB Loc Read">
		<event alias="a">UNC_CHA_OSB.LOCAL_READ</event>
        <event alias="b">UNC_CHA_REQUESTS.READS_LOCAL</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CHA % OSB Rem Read">
		<event alias="a">UNC_CHA_OSB.REMOTE_READ</event>
        <event alias="b">UNC_CHA_REQUESTS.READS_REMOTE</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CHA % cyles Fast asserted">
		<event alias="a">UNC_CHA_DISTRESS_ASSERTED.VERT</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
		<formula>100*a/c</formula>
	</metric>
	
	<metric name="metric_CHA % cyles Fast asserted for dynamic prefetch throttle">
		<event alias="a">UNC_CHA_DISTRESS_ASSERTED.DPT_LOCAL</event>
		<event alias="b">UNC_CHA_DISTRESS_ASSERTED.DPT_NONLOCAL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
		<formula>100*(a+b)/c</formula>
	</metric>
	
    <metric name="metric_CHA RxC IRQ latency (ns)">
        <event alias="a">UNC_CHA_RxC_OCCUPANCY.IRQ</event>
        <event alias="b">UNC_CHA_RxC_INSERTS.IRQ</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_CHA RxC IRQ avg entries">
        <event alias="a">UNC_CHA_RxC_OCCUPANCY.IRQ</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
        <formula>a/c</formula>
    </metric>
	
    <metric name="metric_CHA RxC IRQ % cycles when Q has 18 or more entries">
        <event alias="a">UNC_CHA_CLOCKTICKS</event>
        <event alias="c">UNC_CHA_RxC_OCCUPANCY.IRQ:t=18</event>
       <formula>100*c/a</formula>
    </metric>
    
    <metric name="metric_M2M Rd Trk avg entries">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH0</event>
        <event alias="b">UNC_M2M_TRACKER_OCCUPANCY.CH1</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>((a+b)/mcs_populated_per_socket)/(c/(d*socket_count))</formula>
        <formula socket="0">((a[0]+b[0])/mcs_populated_per_socket)/(c[0]/d)</formula>
        <formula socket="1">((a[1]+b[1])/mcs_populated_per_socket)/(c[1]/d)</formula>
    </metric>

    <metric name="metric_M2M Rd Trk CH0 Latency (ns)">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH0</event>
        <event alias="b">UNC_M2M_TRACKER_INSERTS.CH0</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
    
    <metric name="metric_M2M Rd Trk CH1 Latency (ns)">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH1</event>
        <event alias="b">UNC_M2M_TRACKER_INSERTS.CH1</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
    
    <metric name="metric_M2M TxC AD latency (ns)">
        <event alias="a">UNC_M2M_TxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_M2M_TxC_AD_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_M2M TxC BL latency (ns)">
        <event alias="a">UNC_M2M_TxC_BL_OCCUPANCY.ALL</event>
        <event alias="b">UNC_M2M_TxC_BL_INSERTS.ALL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
	
    <metric name="metric_M2M TxC AD avg entries">
        <event alias="a">UNC_M2M_TxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M TxC BL avg entries">
        <event alias="a">UNC_M2M_TxC_BL_OCCUPANCY.ALL</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M RxC AD latency (ns)">
        <event alias="a">UNC_M2M_RxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_M2M_RxC_AD_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_M2M RxC BL latency (ns)">
        <event alias="a">UNC_M2M_RxC_BL_OCCUPANCY</event>
        <event alias="b">UNC_M2M_RxC_BL_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_M2M RxC AD avg entries">
        <event alias="a">UNC_M2M_RxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M RxC BL avg entries">
        <event alias="a">UNC_M2M_RxC_BL_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M XPT land ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_DEMAND_DROPS.XPT_ALLCH</event>
        <event alias="g">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e+g)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT fwd ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event> 
        <event alias="e">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT drop ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_DEMAND_DROPS.XPT_ALLCH</event>
        <formula>e/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT useful ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <formula>(a)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT waste ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e-a)/(a+c)</formula>
    </metric>

    <metric name="metric_IO_bandwidth_disk_or_network_writes (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_RDCUR</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_RDCUR</event>
         <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_IO_bandwidth_disk_or_network_reads (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_ITOM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOM</event>
        <event alias="c">UNC_CHA_TOR_INSERTS.IO_HIT_ITOMCACHENEAR</event>
        <event alias="d">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
         <formula>(a+b+c+d)*64/1000000</formula>
    </metric>

    <metric name="metric_IO_number of partial PCI writes per sec">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_ITOMCACHENEAR</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
        <formula>a+b</formula>
    </metric>

    <metric name="metric_IO_read cache miss(disk/network writes) bandwidth (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_MISS_RDCUR</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_IO_write cache miss(disk/network reads) bandwidth (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_MISS_ITOM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_memory reads vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <event alias="b">UNC_M_CAS_COUNT.WR</event>
        <formula>a/(a+b)</formula>
    </metric>

    <metric name="metric_memory Page Empty vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <event alias="c">UNC_M_PRE_COUNT.ALL</event>
        <event alias="d">UNC_M_PRE_COUNT.PGT</event>
        <formula>(b*d)/(a*c)</formula>
    </metric>

    <metric name="metric_memory Page Misses vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <event alias="c">UNC_M_PRE_COUNT.ALL</event>
        <event alias="d">UNC_M_PRE_COUNT.PGT</event>
        <formula>(b*(c-d))/(a*c)</formula>
    </metric>

    <metric name="metric_memory Page Hits vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <formula>(a-b)/a</formula>
    </metric>

    <metric name="metric_ItoM operations (fast strings) that reference LLC per instr">
        <throughput-metric-name>metric_ItoM operations (fast strings) that reference LLC per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_ITOM</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_SPECITOM</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>(a+b)/c</formula>
	</metric>
		
    <metric name="metric_% Uops delivered from decoded Icache (DSB)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(a/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from legacy decode pipeline (MITE)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(b/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from microcode sequencer (MS)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(c/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from loop stream detector (LSD)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(d/(a+b+c+d))</formula>
    </metric>
	
	<metric name="metric_FP scalar single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP scalar single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP scalar double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP scalar double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP 128-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 128-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 128-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 128-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 256-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 256-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 256-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 256-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP 512-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 512-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 512-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 512-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DRAM power (watts)">
		<event alias="a">MSR_EVENT:msr=0x619:type=FREERUN:scope=PACKAGE</event>
		<formula>a*15.3/1000000</formula>
	</metric>
	
	<metric name="metric_package power (watts)">
		<event alias="a">MSR_EVENT:msr=0x611:type=FREERUN:scope=PACKAGE</event>
		<formula>a*61/1000000</formula>
	</metric>

	<metric name="metric_core c6 residency %">
		<event alias="a">MSR_EVENT:msr=0x3FD:type=FREERUN:scope=THREAD</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_package c2 residency %">
		<event alias="a">MSR_EVENT:msr=0x60D:type=FREERUN:scope=PACKAGE</event>
		<event alias="b">TSC</event>
		<constant alias="cpu_count">system.sockets[0].cpus.count</constant>      
		<formula>100*a*cpu_count/b</formula>
	</metric>
	
	<metric name="metric_package c6 residency %">
		<event alias="a">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
		<event alias="b">TSC</event>
		<constant alias="cpu_count">system.sockets[0].cpus.count</constant>      
		<formula>100*a*cpu_count/b</formula>
	</metric>
	
	<metric name="metric_core clflush and clflushopt per instr">
        <throughput-metric-name>metric_core clflush and clflushopt per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_CLFLUSH</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_CLFLUSHOPT</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>(a+b)/c</formula>
	</metric>

	<metric name="metric_core PAUSE instr executions per instr">
        <throughput-metric-name>metric_core PAUSE instr executions per txn</throughput-metric-name>
		<event alias="a">MISC_RETIRED.PAUSE_INST</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>

	<metric name="metric_core % cycles in license throttle">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<event alias="f">CORE_POWER.THROTTLE</event>
		<formula>100*f/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in license 1">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*a/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in license 2">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*b/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in license 3">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*c/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in license 4">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*d/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in license 5">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*e/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in non AVX license">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*(a+b)/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in AVX2 license">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*(c+d)/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_core % cycles in AVX-512 license">
		<event alias="a">CORE_POWER.LICENSE_1</event>
		<event alias="b">CORE_POWER.LICENSE_2</event>
		<event alias="c">CORE_POWER.LICENSE_3</event>
		<event alias="d">CORE_POWER.LICENSE_4</event>
		<event alias="e">CORE_POWER.LICENSE_5</event>
		<formula>100*(e)/(a+b+c+d+e)</formula>
	</metric>

	<metric name="metric_L2Wb WbEFtoE evictions per instr">
        <throughput-metric-name>metric_L2Wb WbEFtoE evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA:umask_ext=0xCC3FFF</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2Wb WbEFtoI evictions per instr">
        <throughput-metric-name>metric_L2Wb WbEFtoI evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA:umask_ext=0xCC37FF</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2Wb WbMtoE evictions per instr">
        <throughput-metric-name>metric_L2Wb WbMtoE evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA:umask_ext=0xCC2FFF</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2Wb WbMtoI evictions per instr">
        <throughput-metric-name>metric_L2Wb WbMtoI evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA:umask_ext=0xCC27FF</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

  <metric name="metric_TMA_Frontend_Bound(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( a / ( ( a + b + c + d ) ) - e / ( f ) )</formula>
  </metric>
  <metric name="metric_TMA_..Fetch_Latency(%)">
    <event alias="a">IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</event>
    <event alias="b">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( ( 5 ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....ICache_Misses(%)">
    <event alias="a">ICACHE_16B.IFDATA_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....ITLB_Misses(%)">
    <event alias="a">ICACHE_64B.IFTAG_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....Branch_Resteers(%)">
    <event alias="a">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="c">BACLEARS.ANY</event>
    <formula>100 * ( a / ( b ) + ( ( 10 ) * c / ( b ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......Mispredicts_Resteers(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a / ( a + b ) ) * c / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......Clears_Resteers(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 1 - ( a / ( a + b ) ) ) * c / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......Unknown_Branches(%)">
    <event alias="a">BACLEARS.ANY</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 10 ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....DSB_Switches(%)">
    <event alias="a">DSB2MITE_SWITCHES.PENALTY_CYCLES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....LCP(%)">
    <event alias="a">ILD_STALL.LCP</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....MS_Switches(%)">
    <event alias="a">IDQ.MS_SWITCHES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 3 ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..Fetch_Bandwidth(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</event>
    <formula>100 * ( [ ( 0 ) , ( ( a / ( ( a + b + c + d ) ) - e / ( f ) ) - ( ( 5 ) * g / ( f ) ) ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_....MITE(%)">
    <event alias="a">IDQ.MITE_CYCLES_ANY</event>
    <event alias="b">IDQ.MITE_CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) / 2 )</formula>
  </metric>
  <metric name="metric_TMA_....DSB(%)">
    <event alias="a">IDQ.DSB_CYCLES_ANY</event>
    <event alias="b">IDQ.DSB_CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) / 2 )</formula>
  </metric>
  <metric name="metric_TMA_....LSD(%)">
    <event alias="a">LSD.CYCLES_ACTIVE</event>
    <event alias="b">LSD.CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) / 2 )</formula>
  </metric>
  <metric name="metric_TMA_Bad_Speculation(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <formula>100 * ( [ ( 1 - ( ( a / ( ( a + b + c + d ) ) - e / ( f ) ) + ( d / ( ( a + b + c + d ) ) + ( ( 5 ) * g ) / ( f ) ) + ( c / ( ( a + b + c + d ) ) ) ) ) , ( 0 ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_..Branch_Mispredicts(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="d">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="g">INT_MISC.UOP_DROPPING</event>
    <event alias="h">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="i">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <formula>100 * ( ( a / ( a + b ) ) * ( [ ( 1 - ( ( c / ( ( c + d + e + f ) ) - g / ( h ) ) + ( f / ( ( c + d + e + f ) ) + ( ( 5 ) * i ) / ( h ) ) + ( e / ( ( c + d + e + f ) ) ) ) ) , ( 0 ) ].max ) )</formula>
  </metric>
  <metric name="metric_TMA_..Machine_Clears(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <event alias="h">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="i">MACHINE_CLEARS.COUNT</event>
    <formula>100 * ( [ ( 0 ) , ( ( [ ( 1 - ( ( a / ( ( a + b + c + d ) ) - e / ( f ) ) + ( d / ( ( a + b + c + d ) ) + ( ( 5 ) * g ) / ( f ) ) + ( c / ( ( a + b + c + d ) ) ) ) ) , ( 0 ) ].max ) - ( ( h / ( h + i ) ) * ( [ ( 1 - ( ( a / ( ( a + b + c + d ) ) - e / ( f ) ) + ( d / ( ( a + b + c + d ) ) + ( ( 5 ) * g ) / ( f ) ) + ( c / ( ( a + b + c + d ) ) ) ) ) , ( 0 ) ].max ) ) ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_Backend_Bound(%)">
    <event alias="a">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.RETIRING</event>
    <event alias="e">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( a / ( ( b + c + d + a ) ) + ( ( 5 ) * e ) / ( f ) )</formula>
  </metric>
  <metric name="metric_TMA_..Memory_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="b">EXE_ACTIVITY.BOUND_ON_STORES</event>
    <event alias="c">CYCLE_ACTIVITY.STALLS_TOTAL</event>
    <event alias="d">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="g">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="h">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="i">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="j">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <event alias="k">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( ( ( a + b ) / ( c + ( d + ( e / ( ( f + g + e + h ) ) ) * i ) + b ) ) * ( h / ( ( f + g + e + h ) ) + ( ( 5 ) * j ) / ( k ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....L1_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( [ ( ( a - b ) / ( c ) ) , ( 0 ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_......DTLB_Load(%)">
    <event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="c">CYCLE_ACTIVITY.CYCLES_MEM_ANY</event>
    <event alias="d">CYCLE_ACTIVITY.CYCLES_L1D_MISS</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( [ ( ( 7 ) * a + b ) , ( [ ( c - d ) , ( 0 ) ].max ) ].min / ( e ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_STLB_Hit(%)">
    <event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="c">CYCLE_ACTIVITY.CYCLES_MEM_ANY</event>
    <event alias="d">CYCLE_ACTIVITY.CYCLES_L1D_MISS</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( [ ( ( 7 ) * a + b ) , ( [ ( c - d ) , ( 0 ) ].max ) ].min / ( e ) ) - ( b / ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_STLB_Miss(%)">
    <event alias="a">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Store_Fwd_Blk(%)">
    <event alias="a">LD_BLOCKS.STORE_FORWARD</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( 13 * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Lock_Latency(%)">
    <event alias="a">MEM_INST_RETIRED.LOCK_LOADS</event>
    <event alias="b">MEM_INST_RETIRED.ALL_STORES</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="d">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO</event>
    <formula>100 * ( ( a / b ) * ( [ ( c - 0 ) , ( d - 0 ) ].min ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......Split_Loads(%)">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="b">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="c">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="d">LD_BLOCKS.NO_SR</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a / ( b + c ) ) * d / ( e ) )</formula>
  </metric>
  <metric name="metric_TMA_......4K_Aliasing(%)">
    <event alias="a">LD_BLOCKS_PARTIAL.ADDRESS_ALIAS</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......FB_Full(%)">
    <event alias="a">L1D_PEND_MISS.FB_FULL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....L2_Bound(%)">
    <event alias="a">MEM_LOAD_RETIRED.L2_HIT</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">L1D_PEND_MISS.FB_FULL_PERIODS</event>
    <event alias="e">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="f">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="g">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( a * ( 1 + ( b / ( c ) ) ) ) / ( ( a * ( 1 + ( b / ( c ) ) ) ) + d ) ) * ( ( e - f ) / ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....L3_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_L3_MISS</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......Contested_Accesses(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</event>
    <event alias="f">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HITM</event>
    <event alias="g">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_WITH_FWD</event>
    <event alias="h">MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS</event>
    <event alias="i">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="j">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( ( 48 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 4 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * ( e * ( f / ( f + g ) ) ) + ( ( 47.5 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 4 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * ( h ) ) * ( 1 + ( i / ( j ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......Data_Sharing(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_L3_HIT_RETIRED.XSNP_HIT</event>
    <event alias="f">MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</event>
    <event alias="g">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HITM</event>
    <event alias="h">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_WITH_FWD</event>
    <event alias="i">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="j">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( 47.5 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 4 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * ( e + f * ( 1 - ( g / ( g + h ) ) ) ) * ( 1 + ( i / ( j ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......L3_Hit_Latency(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_RETIRED.L3_HIT</event>
    <event alias="f">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="g">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( 23 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 4 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * ( e ) * ( 1 + ( f / ( g ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......SQ_Full(%)">
    <event alias="a">L1D_PEND_MISS.L2_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....DRAM_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_L3_MISS</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="c">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="d">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="e">MEM_LOAD_RETIRED.L2_HIT</event>
    <event alias="f">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="g">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="h">L1D_PEND_MISS.FB_FULL_PERIODS</event>
    <event alias="i">MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM</event>
    <event alias="j">MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM</event>
    <event alias="k">MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD</event>
    <event alias="l">MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM</event>
    <event alias="m">MEM_LOAD_RETIRED.LOCAL_PMM</event>
    <event alias="n">MEM_LOAD_L3_MISS_RETIRED.REMOTE_PMM</event>
    <formula>100 * ( ( ( a / ( b ) + ( ( c - d ) / ( b ) ) - ( ( ( e * ( 1 + ( f / ( g ) ) ) ) / ( ( e * ( 1 + ( f / ( g ) ) ) ) + h ) ) * ( ( c - d ) / ( b ) ) ) ) - ( ( ( ( ( 1000000 ) * ( n + m ) &gt; g ) ) ? ( ( ( 1 - ( ( ( 19 * ( i * ( 1 + ( f / ( g ) ) ) ) + 10 * ( ( j * ( 1 + ( f / ( g ) ) ) ) + ( k * ( 1 + ( f / ( g ) ) ) ) + ( l * ( 1 + ( f / ( g ) ) ) ) ) ) / ( ( 19 * ( i * ( 1 + ( f / ( g ) ) ) ) + 10 * ( ( j * ( 1 + ( f / ( g ) ) ) ) + ( k * ( 1 + ( f / ( g ) ) ) ) + ( l * ( 1 + ( f / ( g ) ) ) ) ) ) + ( 25 * ( ( m * ( 1 + ( f / ( g ) ) ) ) ) + 33 * ( ( n * ( 1 + ( f / ( g ) ) ) ) ) ) ) ) ) ) * ( a / ( b ) + ( ( c - d ) / ( b ) ) - ( ( ( e * ( 1 + ( f / ( g ) ) ) ) / ( ( e * ( 1 + ( f / ( g ) ) ) ) + h ) ) * ( ( c - d ) / ( b ) ) ) ) ) ) : ( 0 ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......MEM_Bandwidth(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c4</event>
    <formula>100 * ( ( [ ( a - 0 ) , ( b - 0 ) ].min ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......MEM_Latency(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD</event>
    <event alias="c">OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c4</event>
    <formula>100 * ( ( [ ( a - 0 ) , ( b - 0 ) ].min ) / ( a ) - ( ( [ ( a - 0 ) , ( c - 0 ) ].min ) / ( a ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Local_DRAM(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM</event>
    <event alias="f">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="g">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( 66.5 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 23 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * e * ( 1 + ( f / ( g ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_........Remote_DRAM(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
	<constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM</event>
    <event alias="f">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="g">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( 131 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 23 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * e * ( 1 + ( f / ( g ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_........Remote_Cache(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM</event>
    <event alias="f">MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD</event>
    <event alias="g">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="h">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>100 * ( ( ( ( 120 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 23 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * e + ( ( 120 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) - ( 23 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) ) * f ) * ( 1 + ( g / ( h ) ) / 2 ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_....PMM_Bound(%)">
    <event alias="a">MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM</event>
    <event alias="e">MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD</event>
    <event alias="f">MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM</event>
    <event alias="g">MEM_LOAD_RETIRED.LOCAL_PMM</event>
    <event alias="h">MEM_LOAD_L3_MISS_RETIRED.REMOTE_PMM</event>
    <event alias="i">CYCLE_ACTIVITY.STALLS_L3_MISS</event>
    <event alias="j">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="k">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="l">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="m">MEM_LOAD_RETIRED.L2_HIT</event>
    <event alias="n">L1D_PEND_MISS.FB_FULL_PERIODS</event>
    <formula>100 * ( ( ( ( ( 1000000 ) * ( h + g ) &gt; c ) ) ? ( ( ( 1 - ( ( ( 19 * ( a * ( 1 + ( b / ( c ) ) ) ) + 10 * ( ( d * ( 1 + ( b / ( c ) ) ) ) + ( e * ( 1 + ( b / ( c ) ) ) ) + ( f * ( 1 + ( b / ( c ) ) ) ) ) ) / ( ( 19 * ( a * ( 1 + ( b / ( c ) ) ) ) + 10 * ( ( d * ( 1 + ( b / ( c ) ) ) ) + ( e * ( 1 + ( b / ( c ) ) ) ) + ( f * ( 1 + ( b / ( c ) ) ) ) ) ) + ( 25 * ( ( g * ( 1 + ( b / ( c ) ) ) ) ) + 33 * ( ( h * ( 1 + ( b / ( c ) ) ) ) ) ) ) ) ) ) * ( i / ( j ) + ( ( k - l ) / ( j ) ) - ( ( ( m * ( 1 + ( b / ( c ) ) ) ) / ( ( m * ( 1 + ( b / ( c ) ) ) ) + n ) ) * ( ( k - l ) / ( j ) ) ) ) ) ) : ( 0 ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....Store_Bound(%)">
    <event alias="a">EXE_ACTIVITY.BOUND_ON_STORES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Store_Latency(%)">
    <event alias="a">L2_RQSTS.RFO_HIT</event>
    <event alias="b">MEM_INST_RETIRED.LOCK_LOADS</event>
    <event alias="c">MEM_INST_RETIRED.ALL_STORES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="e">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO</event>
    <formula>100 * ( ( ( a * ( 10 ) * ( 1 - ( b / c ) ) ) + ( 1 - ( b / c ) ) * ( [ ( d - 0 ) , ( e - 0 ) ].min ) ) / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......False_Sharing(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
    <constant alias="c">system.tsc_freq</constant>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <event alias="e">OCR.DEMAND_RFO.L3_HIT.SNOOP_HITM</event>
    <formula>100 * ( ( 48 * ( ( ( a ) / b ) * c / ( 1000000000 ) / ( ( durationtimeinmilliseconds / 1000 ) ) ) ) * e / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......Split_Stores(%)">
    <event alias="a">MEM_INST_RETIRED.SPLIT_STORES</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Streaming_Stores(%)">
    <event alias="a">OCR.STREAMING_WR.ANY_RESPONSE</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( 9 * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......DTLB_Store(%)">
    <event alias="a">DTLB_STORE_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( [ ( ( ( 7 ) * a + b ) / ( c ) ) , ( 1 ) ].min )</formula>
  </metric>
  <metric name="metric_TMA_........Store_STLB_Hit(%)">
    <event alias="a">DTLB_STORE_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( [ ( ( ( 7 ) * a + b ) / ( c ) ) , ( 1 ) ].min ) - ( b / ( c ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Store_STLB_Miss(%)">
    <event alias="a">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..Core_Bound(%)">
    <event alias="a">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.RETIRING</event>
    <event alias="e">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="h">EXE_ACTIVITY.BOUND_ON_STORES</event>
    <event alias="i">CYCLE_ACTIVITY.STALLS_TOTAL</event>
    <event alias="j">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="k">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <formula>100 * ( [ ( 0 ) , ( ( a / ( ( b + c + d + a ) ) + ( ( 5 ) * e ) / ( f ) ) - ( ( ( g + h ) / ( i + ( j + ( d / ( ( b + c + d + a ) ) ) * k ) + h ) ) * ( a / ( ( b + c + d + a ) ) + ( ( 5 ) * e ) / ( f ) ) ) ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_....Divider(%)">
    <event alias="a">ARITH.DIVIDER_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....Ports_Utilization(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_TOTAL</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="c">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="d">PERF_METRICS.RETIRING</event>
    <event alias="e">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="f">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="g">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="h">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="i">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="j">ARITH.DIVIDER_ACTIVE</event>
    <formula>100 * ( ( ( (j-0) &lt; ( a - b ) ) ) ? ( ( a - b + ( c + ( d / ( ( e + f + d + g ) ) ) * h ) ) / ( i ) ) : ( ( c + ( d / ( ( e + f + d + g ) ) ) * h ) / ( i ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_0(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_TOTAL</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_........Serializing_Operation(%)">
    <event alias="a">RESOURCE_STALLS.SCOREBOARD</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Slow_Pause(%)">
    <event alias="a">MISC_RETIRED.PAUSE_INST</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( 37 * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........Mixing_Vectors(%)">
    <event alias="a">UOPS_ISSUED.VECTOR_WIDTH_MISMATCH</event>
    <event alias="b">UOPS_ISSUED.ANY</event>
    <formula>100 * ( a / b )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_1(%)">
    <event alias="a">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_2(%)">
    <event alias="a">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_3m(%)">
    <event alias="a">UOPS_EXECUTED.CYCLES_GE_3</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........ALU_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_0</event>
    <event alias="b">UOPS_DISPATCHED.PORT_1</event>
    <event alias="c">UOPS_DISPATCHED.PORT_5</event>
    <event alias="d">UOPS_DISPATCHED.PORT_6</event>
    <event alias="e">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a + b + c + d ) / ( 4 * ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_0(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_0</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_1(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_1</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_5(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_5</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_6(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_6</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_2_3</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( 2 * ( b ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Store_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_4_9</event>
    <event alias="b">UOPS_DISPATCHED.PORT_7_8</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a + b ) / ( 4 * ( c ) ) )</formula>
  </metric>
  <metric name="metric_TMA_Retiring(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <formula>100 * ( a / ( ( b + c + a + d ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Light_Operations(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="f">UOPS_ISSUED.ANY</event>
    <event alias="g">IDQ.MS_UOPS</event>
    <formula>100 * ( [ ( 0 ) , ( ( a / ( ( b + c + a + d ) ) ) - ( ( ( ( ( a / ( ( b + c + a + d ) ) ) * ( e ) ) / f ) * g / ( e ) ) ) ) ].max )</formula>
  </metric>
  <metric name="metric_TMA_....FP_Arith(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <event alias="c">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="g">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="h">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="i">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="j">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="k">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="l">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="m">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="n">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="o">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <formula>100 * ( ( a / b ) + ( ( c + d ) / ( ( e / ( ( f + g + e + h ) ) ) * ( i ) ) ) + ( ( j + k + l + m + n + o ) / ( ( e / ( ( f + g + e + h ) ) ) * ( i ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......X87_Use(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <formula>100 * ( a / b )</formula>
  </metric>
  <metric name="metric_TMA_......FP_Scalar(%)">
    <event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="e">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="f">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="g">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( ( a + b ) / ( ( c / ( ( d + e + c + f ) ) ) * ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......FP_Vector(%)">
    <event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="c">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="e">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="f">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <event alias="g">PERF_METRICS.RETIRING</event>
    <event alias="h">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="i">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="j">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="k">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( ( a + b + c + d + e + f ) / ( ( g / ( ( h + i + g + j ) ) ) * ( k ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....Other_Light_Ops(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <event alias="c">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="g">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="h">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="i">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="j">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="k">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="l">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="m">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="n">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="o">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <formula>100 * ( 1 - ( ( a / b ) + ( ( c + d ) / ( ( e / ( ( f + g + e + h ) ) ) * ( i ) ) ) + ( ( j + k + l + m + n + o ) / ( ( e / ( ( f + g + e + h ) ) ) * ( i ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Heavy_Operations(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="f">UOPS_ISSUED.ANY</event>
    <event alias="g">IDQ.MS_UOPS</event>
    <formula>100 * ( ( ( ( ( a / ( ( b + c + a + d ) ) ) * ( e ) ) / f ) * g / ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....Microcode_Sequencer(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="f">UOPS_ISSUED.ANY</event>
    <event alias="g">IDQ.MS_UOPS</event>
    <formula>100 * ( ( ( ( a / ( ( b + c + a + d ) ) ) * ( e ) ) / f ) * g / ( e ) )</formula>
  </metric>
  <metric name="metric_TMA_......Assists(%)">
    <event alias="a">ASSISTS.ANY</event>
    <event alias="b">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>100 * ( ( 100 * ( 5 ) ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_Info_Thread_IPC">
    <event alias="a">INST_RETIRED.ANY</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>a / ( b )</formula>
  </metric>
  <metric name="metric_TMA_Info_Thread_UPI">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="f">INST_RETIRED.ANY</event>
    <formula>( ( a / ( ( b + c + a + d ) ) ) * ( e ) ) / f</formula>
  </metric>
  <metric name="metric_TMA_Info_Thread_SLOTS">
    <event alias="a">TOPDOWN.SLOTS:perf_metrics</event>
    <formula>a</formula>
  </metric>
  <metric name="metric_TMA_Info_Thread_IpTB">
    <event alias="a">INST_RETIRED.ANY</event>
    <event alias="b">BR_INST_RETIRED.NEAR_TAKEN</event>
    <formula>a / b</formula>
  </metric>
  <metric name="metric_TMA_Info_Core_CoreIPC">
    <event alias="a">INST_RETIRED.ANY</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>a / ( b )</formula>
  </metric>
  <metric name="metric_TMA_Info_Core_ILP">
    <event alias="a">UOPS_EXECUTED.THREAD</event>
    <event alias="b">UOPS_EXECUTED.CORE_CYCLES_GE_1</event>
    <constant alias="threads">system.sockets[0][0].size</constant>
    <formula>a / ( ( threads &gt; 1 ) ? ( ( b / 2 ) ) : ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_Info_Core_FP_Arith_Utilization">
    <event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="c">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="e">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="f">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="g">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="h">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <event alias="i">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>( ( a + b ) + ( c + d + e + f + g + h ) ) / ( 2 * ( i ) )</formula>
  </metric>
  <metric name="metric_TMA_Info_System_GFLOPs">
    <event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="c">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="e">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="f">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="g">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="h">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <formula>( ( ( 1 * ( a + b ) + 2 * c + 4 * ( d + e ) + 8 * ( f + g ) + 16 * h ) ) / ( 1000000000 ) ) / ( ( durationtimeinmilliseconds / 1000 ) )</formula>
  </metric>
  <metric name="metric_TMA_Info_System_SMT_2T_Utilization">
    <event alias="a">CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_DISTRIBUTED</event>
    <constant alias="threads">system.sockets[0][0].size</constant>
    <formula>( threads &gt; 1 ) ? ( 1 - a / b ) : ( 0 )</formula>
  </metric>
  <metric name="metric_TMA_Info_System_Time">
    <constant alias="durationtimeinmilliseconds">1000</constant>
    <formula>( durationtimeinmilliseconds / 1000 )</formula>
  </metric>
  <metric name="metric_TMA_Info_Memory_Load_Miss_Real_Latency">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="b">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="c">MEM_LOAD_RETIRED.FB_HIT</event>
    <formula>a / ( b + c )</formula>
  </metric>
  <metric name="metric_TMA_Info_Memory_MLP">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="b">L1D_PEND_MISS.PENDING_CYCLES</event>
    <formula>a / b</formula>
  </metric>
  <metric name="metric_TMA_Info_Bottleneck_Mispredictions">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="d">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="g">INT_MISC.UOP_DROPPING</event>
    <event alias="h">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="i">INT_MISC.RECOVERY_CYCLES:c1:e1</event>
    <event alias="j">IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</event>
    <event alias="k">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="l">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="m">ICACHE_16B.IFDATA_STALL</event>
    <event alias="n">ICACHE_64B.IFTAG_STALL</event>
    <event alias="o">BACLEARS.ANY</event>
    <event alias="p">DSB2MITE_SWITCHES.PENALTY_CYCLES</event>
    <event alias="q">ILD_STALL.LCP</event>
    <event alias="r">IDQ.MS_SWITCHES</event>
    <formula>100 * ( ( ( a / ( a + b ) ) * ( [ ( 1 - ( ( c / ( ( c + d + e + f ) ) - g / ( h ) ) + ( f / ( ( c + d + e + f ) ) + ( ( 5 ) * i ) / ( h ) ) + ( e / ( ( c + d + e + f ) ) ) ) ) , ( 0 ) ].max ) ) + ( ( 5 ) * j / ( h ) ) * ( ( a / ( a + b ) ) * k / ( l ) ) / ( ( m / ( l ) ) + ( n / ( l ) ) + ( k / ( l ) + ( ( 10 ) * o / ( l ) ) ) + ( p / ( l ) ) + ( q / ( l ) ) + ( ( 3 ) * r / ( l ) ) ) )</formula>
  </metric>
  
    <metric name="metric_CPU Core utilization_SUM %">
		<event alias="a">CPU_CLK_UNHALTED.REF_DISTRIBUTED:percore</event>
		<!-- if you have 32 cores in the system (16 per socket), you will see 3200% as the
			reported CPU utilization assuming all cores are 100% active -->
		<!-- Reference clock counts at 25MHz and hence divide by 25000000 below -->
		<constant alias="threads">system.sockets[0][0].size</constant>      
		<formula>100*(a/threads)/25000000</formula>
	</metric>
	
	<metric name="metric_core initiated local dram read bandwidth (MB/sec)">
         <!-- Includes demand + L2pref for all data read, code read and rfo that hit local dram + L3 Pref 
		 that might have gone to Local dram, local PMM, local NON_DRAM, or Remote cache-->
        <event alias="a">OCR.READS_TO_CORE.LOCAL_DRAM</event>
        <event alias="b">OCR.HWPF_L3.L3_MISS_LOCAL</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_core initiated remote dram read bandwidth (MB/sec)">
         <!-- Includes demand + L2pref + L3 pref for all data read, code read and rfo that hit remote dram + L3 Pref 
		 that might have gone to Remote dram, remote PMM, Remote NON_DRAM, or Remote cache  -->
        <event alias="a">OCR.READS_TO_CORE.REMOTE_DRAM</event>
        <event alias="b">OCR.HWPF_L3.REMOTE</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

	<metric name="metric_core SW prefetch NTA per instr">
        <throughput-metric-name>metric_core SW prefetch NTA per txn</throughput-metric-name>
		<event alias="a">SW_PREFETCH_ACCESS.NTA</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>

	<metric name="metric_TMA_Metrics_Version">
		<formula>4.2</formula>
	</metric>
  
	<metric name="metric_EDP EMON Sampling time (seconds)">
		<constant alias="time">$samplingTime</constant>      
		<formula>time</formula>
	</metric>

	<metric name="metric_EDP EMON total number of samples">
		<constant alias="samples">$processed_samples</constant>      
		<formula>samples</formula>
	</metric>

  <metric name="metric_EDP ICX XML version">
 		<constant alias="version">4.27</constant>
		<formula>version</formula>
   </metric>

  </root>
